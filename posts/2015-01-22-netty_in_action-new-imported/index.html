<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Обзор книги Netty in Action | volyx</title>
<meta name=keywords content="old-posts"><meta name=description content="В выпуске тонкости экзекъютор сервисов, сохранение объектов в Редис и способы упаковки приложения в исполняемый архив."><meta name=author content="volyx"><link rel=canonical href=https://volyx.in/posts/2015-01-22-netty_in_action-new-imported/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://volyx.in/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://volyx.in/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://volyx.in/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://volyx.in/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://volyx.in/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://volyx.in/posts/2015-01-22-netty_in_action-new-imported/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Обзор книги Netty in Action"><meta property="og:description" content="В выпуске тонкости экзекъютор сервисов, сохранение объектов в Редис и способы упаковки приложения в исполняемый архив."><meta property="og:type" content="article"><meta property="og:url" content="https://volyx.in/posts/2015-01-22-netty_in_action-new-imported/"><meta property="og:image" content="https://volyx.in/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-01-22T00:00:00+00:00"><meta property="article:modified_time" content="2015-01-22T00:00:00+00:00"><meta property="og:site_name" content="volyx"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://volyx.in/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Обзор книги Netty in Action"><meta name=twitter:description content="В выпуске тонкости экзекъютор сервисов, сохранение объектов в Редис и способы упаковки приложения в исполняемый архив."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://volyx.in/posts/"},{"@type":"ListItem","position":2,"name":"Обзор книги Netty in Action","item":"https://volyx.in/posts/2015-01-22-netty_in_action-new-imported/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Обзор книги Netty in Action","name":"Обзор книги Netty in Action","description":"В выпуске тонкости экзекъютор сервисов, сохранение объектов в Редис и способы упаковки приложения в исполняемый архив.","keywords":["old-posts"],"articleBody":"\nКак сказал David Wheeler, все проблемы в Computer Science могут быть решены еще одним уровнем абстракции. Netty как раз предлагает такой уровень абстракции для клиент-серверных приложений, работающих через NIO(non-blocking input-output). Netty упрощает разработку TCP, UDP серверов, но также дает доступ к использованию низкоуровнего API, представляя свои высокоуровневые абстракции.\nБлокирующий против неблокирующего ввода-вывода в JVM Продолжающийся рост веба увеличивает потребность в обработке все большего количества данных через сеть и возможностей масштабирования. Эффективность приложений выходит на первое место и встречается со спросом на эту эффективность. К счастью, Java уже поставляется со всеми инструментами, необходимыми для создания эффективных и масштабируемых приложений. Хотя ранние версии Java поддерживали работу с сетью, в Java 1.4 был представлен NIO API, который упрощал разработку клиент-серверных приложений.\nНовый ввод-вывод (NIO.2), представленный в Java 7, дает возможность писать асинхронный, работающий с сетью код и также предлагает более высокоуровневый API , чем его предшественник.\nДля работы с сетью у вас есть всего два варианта:\nИспользовать IO, известный как блокирующий ввод-вывод Использовать NIO, известный как новый/неблокирующий ввод-вывод Блокирующие сокеты\nНеблокирующие сокеты\nНа рисунках 1,2 показано, что блокирующий ввод-вывод использует по выделенному потоку на на каждое соединение, это означает, что мы имеем связь один-к-одному между подключениями и потоками, которая ограничивает количество потоков, которое может создать JVM.\nЗапомнив это концептуальное отличие, попробуем написать простой сервер, используя разные подходы. Сервер будет принимать запросы от клиента, и отправлять их назад.\n{% highlight java %} import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.ServerSocket; import java.net.Socket;\npublic class PlainEchoServer { public void serve(int port) throws IOException { final ServerSocket socket = new ServerSocket(port); // \u003c1\u003e try { while (true) { final Socket clientSocket = socket.accept(); // \u003c2\u003e System.out.println(“Accepted connection from \" + clientSocket); new Thread(new Runnable() { // \u003c3\u003e @Override public void run() { try { BufferedReader reader = new BufferedReader( new InputStreamReader(clientSocket.getInputStream())); PrintWriter writer = new PrintWriter(clientSocket .getOutputStream(), true); while(true) { // \u003c4\u003e writer.println(reader.readLine()); writer.flush();\n} } catch (IOException e) { e.printStackTrace(); try { clientSocket.close(); } catch (IOException ex) { // ignore on close } } } }).start(); // \u003c5\u003e } } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) throws IOException { new PlainEchoServer().serve(9000); } } {% endhighlight %}\nПривязываем сервер к порту Блокируем основной поток, пока клиент не подключится Создаем новый поток и обрабатываем подключение клиента Читаем введенные клиентом данные и записываем их назад Запускаем поток Подключиться к такому серверу можно с помощью telnet, например вот так:\n{% highlight bash %} telnet localhost 9000 {% endhighlight %}\nНа каждого нового клиента требуется создать отдельный поток. Можно, конечно, сделать какой-нибудь pool потоков, чтобы уменьшить затраты на создание каждый раз нового потока, и переиспользовать уже созданные, но это поможет лишь только на время. Основная проблема все же остается: количество одновременных клиентов будет ограничено количеством потоков, обрабатывающих их. Когда приложению необходимо обрабатывать одновременно тысячи клиентов, это становится большой проблемой.\nЭта проблема исчезает, если мы будем использовать NIO, как например, в следующем примере. Но для начала важно узнать основные концепции в NIO.\nОсновные концепции NIO Java 7 представила новый NIO API, известный как NIO.2, но можно так же использовать и “просто” NIO. Хотя новый API также асинхронный, он отличается от исходной реализации NIO, как API, так и реализацией. Хотя API не сильно отличаются, они оба имеют одинаковые возможности. Например, обе реализации используют одну и ту же абстракцию под названием ByteBuffer, как обертку для данных.\nBytebuffer ByteBuffer - это основа для обоих NIO APIs, так же как и в Netty. ByteBuffer может быть создан как и в Java куче (heap), так и напрямую, что означает, что он будет хранится вне кучи. Использование буфера напрямую обычно быстрее, когда мы передаем его какому-то каналу (channel), но стоимость создание и очистки/удаления такого буфера выше. В обоих случаях, API Bytebuffer’а один и тот же, который позволяет одним унифицированный образом управлять данными в буфере. ByteBuffer позволяет одним и тем же данным быть легко доступными между разными экземплярами Bytebuffer, без необходимости копировать внутренние данные. Так же он предоставляет другие операции, который ограничивают видимость внутренних данных.\nSlicing ByteBuffer\nРазрезание (Slicing) ByteBuffer позволяет создать новый экземпляр, который будет ссылаться на те же данные, как и исходный ByteBuffer, но делать доступным только часть этих данных. Это полезно для минимизации количества копирований данных, но разрешает доступ только к части этих данных.\nТипичное использование ByteBuffer включает следущее:\nЗаписать данные в ByteBuffer Вызвать ByteBuffer.flip() для смены режима на чтение Чтение данных из ByteBuffer Вызов либо ByteBuffer.clear(), либо ByteBuffer.compact() Когда данные пишутся в ByteBuffer, он следит за количеством данных, записанных в него, сохраняя позицию индекса записи. Перед тем, как прочитать данные нужно вызвать Bytebuffer.flip(), чтобы сменить режим с записи на режим чтения. Вызов метода ByteBuffer.flip() устанавливает ограничение в ByteBuffer в текущую позицию, а затем устанавливает ее в 0. Таким образом можно считать все данные из ByteBuffer.\nЧтобы опять записать данные в ByteBuffer, нужно вернуться в режим чтения, а затем вызвать следующие методы:\nByteBuffer.clear() Очищает все данные в буфере ByteBuffer.compact() Очищает только те данные, которые были прочтены, и перемещает все непрочитанные данные в начало и сдвигает позицию, типичное использование: {% highlight java %} Channel inChannel = ….; ByteBuffer buf = ByteBuffer.allocate(48); int bytesRead = -1; do { bytesRead = inChannel.read(buf); //\u003c1\u003e if (bytesRead != -1) { buf.flip(); //\u003c2\u003e while(buf.hasRemaining()){ System.out.print((char) buf.get()); //\u003c3\u003e } buf.clear(); //\u003c4\u003e } } while (bytesRead != -1); inChannel.close(); {% endhighlight %}\nПрочитать данные из канала (Channel) в ByteBuffer Подготовим буфер для чтения Прочитаем байты из ByteBuffer,с каждым вызовом get() обновляем индекс позиции на 1 Подготовим буфер для записи Теперь, когда понятно, как работать с ByteBuffer, рассмотрим концепцию селекторов (Selectors).\nРабота с NIO селекторами (Selectors) NIO API использует основанный на селекторах подход для обработки сетевых событий и данных. Канал (channel) выступает в роли соединения между сущностями, способными осуществлять операции ввода-вывода над такими сущностями как как файл или сокет. Селектор это NIO компонент, который определяет готов ли канал или несколько каналов для чтения/записи, получается что один селектор способен обработать множество подключений, сводящий на нет необходимость для использования модели поток-на-соединение, как было блокирующем сервере из первого примера.\nЧтобы использовать селектор нужно выполнит следующие шаги:\nСоздать один или несколько селекторов, в которых можно зарегистрировать каналы (channels) Когда каналы зарегистрированы, нужно указать события,к которые будут прослушиваться. Существует 4 типа событий: OP_ACCEPT OP_CONNECT OP_READ OP_WRITE Когда каналы зарегистрированы, необходимо вызвать метод Selector.select(), который заблокирует основной поток, пока какое-нибудь из событий не произойдет. Когда метод разблокируется, можно получить все экземпляры SelectionKey(содержит ссылки на зарегистрированный канал и тип события) и выполнить свой код. Что конкретно выполнять зависит от типа события, которое пришло. SelectedKey может содержать больше чем одно событие в один промежуток времени. Чтобы увидеть как это работает на деле, нужно реализовать неблокирующую версию сервера из предыдущего примера.\n{% highlight java %} import java.io.IOException; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.ServerSocketChannel; import java.nio.channels.SocketChannel; import java.util.Iterator; import java.util.Set;\npublic class PlainNioEchoServer { public void serve(int port) throws IOException { System.out.println(“Listening for connections on port \" + port); ServerSocketChannel serverChannel = ServerSocketChannel.open(); ServerSocket ss = serverChannel.socket(); InetSocketAddress address = new InetSocketAddress(port); ss.bind(address); // \u003c1\u003e serverChannel.configureBlocking(false); Selector selector = Selector.open(); serverChannel.register(selector, SelectionKey.OP_ACCEPT); // \u003c2\u003e while (true) { try { selector.select(); // \u003c3\u003e } catch (IOException ex) { ex.printStackTrace(); // handle in a proper way break; } Set readyKeys = selector.selectedKeys();// \u003c4\u003e Iterator iterator = readyKeys.iterator(); while (iterator.hasNext()) { SelectionKey key = (SelectionKey) iterator.next(); iterator.remove();//; \u003c5\u003e try { if (key.isAcceptable()) { ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel client = server.accept();// \u003c6\u003e System.out.println(“Accepted connection from \" + client); client.configureBlocking(false); client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, ByteBuffer.allocate(100));// \u003c7\u003e } if (key.isReadable()) {// \u003c8\u003e SocketChannel client = (SocketChannel) key.channel(); ByteBuffer output = (ByteBuffer) key.attachment(); client.read(output);// \u003c9\u003e } if (key.isWritable()) {// \u003c10\u003e SocketChannel client = (SocketChannel) key.channel(); ByteBuffer output = (ByteBuffer) key.attachment(); output.flip(); client.write(output);// \u003c11\u003e output.compact(); } } catch (IOException ex) { key.cancel(); try { key.channel().close(); } catch (IOException cex) { } } } } }\npublic static void main(String[] args) throws IOException { new PlainNioEchoServer().serve(9091); } } {% endhighlight %}\nПривязываем сервер к порту Регистрируем канал с селектором для прослушивания событий типа “accept” Блокируем пока какой-то селектор не сработает Получаем все экземпляры SelectedKey Убираем SelectedKey из итератора Принимаем соединение клиента Регистрируем соединение в селекторе и устанавливаем ByteBuffer Проверяем SelectedKey на чтение Читаем данные в ByteBuffer Проверяем SelectedKey на запись Записываем данные их ByteBuffer в канал Этот пример гораздо сложнее, чем предыдущая версия. Такая сложность - это своего рода компромисс. Асинхронный код обычно сложнее, чем его синхронная версия. Семантически, исходный NIO и NIO.2 API одинаковые, но на самом деле их реализация разная. Далее мы разработаем 3 версию нашего сервера.\nEchoServer, основанный на NIO.2 В отличие от первой реализации NIO, NIO.2 позволяет отлавливать конкретные операции ввода-вывода и завершить их специальным классом-обработчиком (CompletionHandler). Это класс должен выполняется после завершения какой-либо операции. Таким образом он запускается внутренним механизмом NIO и реализация скрыта от разработчика. Так же гарантируется,что только один обработчик будет выполняться для одного канала в один промежуток времени. Этот подход позволяет упростить код, потому что убирается вся сложность работы с многопоточным кодом.\nОсновное различие между NIO и NIO.2 это то, что не требуется самому проверять - произошло ли какое-то событие и вызывать необходимый обработчик. В NIO.2 нужно только запустить IO (input-output) операцию и зарегистрировать обработчик (CompletionHandler), который будет получать уведомления, когда операция завершится. Поэтому необходимость писать свою собственную логику на проверку завершения операция отпадает. Сейчас, давайте посмотрим как будет выглядеть асинхронный EchoServer , реализованный с помощью NIO.2 API.\n{% highlight java %} import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.AsynchronousServerSocketChannel; import java.nio.channels.AsynchronousSocketChannel; import java.nio.channels.CompletionHandler; import java.util.concurrent.CountDownLatch;\npublic class PlainNio2EchoServer {\npublic void serve(int port) throws IOException { System.out.println(\"Listening for connections on port \" + port); final AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open(); InetSocketAddress address = new InetSocketAddress(port); serverChannel.bind(address); // \u003c1\u003e final CountDownLatch latch = new CountDownLatch(1); serverChannel.accept(null, new CompletionHandler() { // \u003c2\u003e @Override public void completed(final AsynchronousSocketChannel channel, Object attachment) { serverChannel.accept(null, this);// \u003c3\u003e ByteBuffer buffer = ByteBuffer.allocate(100); channel.read(buffer, buffer, new EchoCompletionHandler(channel));// \u003c4\u003e } @Override public void failed(Throwable throwable, Object attachment) { try { serverChannel.close();// \u003c5\u003e } catch (IOException e) { // ingnore on close } finally { latch.countDown(); } } }); try { latch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } private final class EchoCompletionHandler implements CompletionHandler { private final AsynchronousSocketChannel channel; EchoCompletionHandler(AsynchronousSocketChannel channel) { this.channel = channel; } @Override public void completed(Integer result, ByteBuffer buffer) { buffer.flip(); channel.write(buffer, buffer, new CompletionHandler() { // \u003c6\u003e @Override public void completed(Integer result, ByteBuffer buffer) { if (buffer.hasRemaining()) { channel.write(buffer, buffer, this);// \u003c7\u003e } else { buffer.compact(); channel.read(buffer, buffer, EchoCompletionHandler.this);// \u003c8\u003e } } @Override public void failed(Throwable exc, ByteBuffer attachment) { try { channel.close(); } catch (IOException e) { // ingnore on close } } }); } @Override public void failed(Throwable exc, ByteBuffer attachment) { try { channel.close(); } catch (IOException e) { // ingnore on close } } } public static void main(String[] args) throws IOException { new PlainNio2EchoServer().serve(9092); } } {% endhighlight %}\nПривяжем сервер к порту Начинаем принимать новые подключения. Как только соединение установлено - ompletionHandler будет вызван Опять принимаем новый соединения Запускаем операцию чтения из channel, CompletionHandler будет уведомлен, когда что-нибудь будет прочитано Закрываем socket если произошла ошибка Запускаем операцию записи в channel, CompletionHandler будет уведомлен, когда что-нибудь будет записано Запускаем еще раз операцию чтения, если что-то осталось в ByteBuffer Запускаем операцию чтения в channel, CompletionHandler будет уведомлен, когда что-нибудь будет прочитано На первый взгляд может показаться, что в NIO.2 гораздо больше кода, чем в предыдущем примере с NIO. Но можно обратить внимание, что NIO.2 берет обработку многопоточности на себя и также создание так называемого цикла событий (event loop) . Этот подход упрощает разработку многопоточного приложения на NIO, даже если на первый взгляд код кажется сложным. Так как сложность приложений увеличивается, пропасть между этими подходами становится более очевидной, потому что во второй версии получается более читаемый код. Далее мы посмотрим на проблемы, который существуют в обоих реализациях NIO.\nПроблемы с NIO и как Netty решает эти проблемы Далее будут рассмотрены некоторые проблемы и ограничения реализации в Java NIO API, и как Netty решает эти проблемы. Если вы уже используете классы из пакета NIO - это шаг в правильном направлении, но пользователи весьма ограничены в способах его использования. Проблемы, с которыми вы столкнетесь, являются результатом дизайна, который был сделан в прошлом, и который сейчас не так то легко поменять.\nПроблемы кроссплатформенности и совместимости NIO фреймворк довольно низкоуровневый и сильно зависит от того, как сама операционная система обрабатывает операции ввода-вывода. Поэтому выполнить требование унифицированного API в Java, который должен вести себя одинаково на всех платформах, не очень простая задача.\nКогда используешь NIO часто можно заметить, что код хорошо работает под Linux, например, в отличие от Windows. Это утверждение справедливо, кстати, не только для NIO.\n[TIP] Даже если вы не используете NIO, очень важно тестировать ваше приложение на всех операционных системах, которые хотите поддерживать. Если все ваши тесты успешно выполняются на рабочей станции с Linux, удостоверьтесь, что они так же себя ведут и на других ОС. Если не проверили - приготовьтесь к неожиданностям.\nМожет показаться, что NIO.2 поддерживается только в Java 7, и если ваше приложение работает на Java 6, то вы не сможете его использовать. Так же пока еще нет поддержки в NIO.2 каналов, работающих с датаграмами (datagram channels) (для приложений использующих UDP), поэтому использование NIO.2 ограничивается только TCP протоколом. Netty успешно скрывает эту проблему, и предоставляет общий API, который работает одинаково и на Java 6 и на Java 7. Не придется беспокоиться о версии Java, Netty API будет работать одинаково хорошо и предоставлять простой и удобный интерфейс.\nИспользовать ByteBuffer … или нет Как вы видели ранее, ByteBuffer используется, как контейнер данных. К сожалению, JDK не имеет реализации контейнера ByteBuffer, которая бы позволяла обернуть массив экземпляров ByteBuffer. Эта функциональность бы очень пригодилась для минимизации количества копирований данных. Если вы вдруг решили реализовать эту структуру самостоятельно, не теряйте зря время, ByteBuffer имеет приватный конструктор, и поэтому невозможно от него наследоваться. Netty предоставляет свою реализацию ByteBuffer, которая обходит эти ограничения и предоставляет несколько вариантов конструкторов, методов для ByteBuffer в своем простом API.\nРассеивание данных и сбор (Scattering and gathering may leak) Многие реализации каналов (channel) поддерживают рассеивание данных и сбор (scattering and gathering). Этото функционал позволяет читать и писать из нескольких экземпляров ByteBuffer одновременно, при этом с большей производительностью. Таким способом устроено ядро операционной системы, которое дает большую производительность на чтение/запись, потому что ядро ОС гораздо ближе к “железу”, и знает как обрабатывать данные наиболее эффективным способом. Рассеивание/сбор часто используется для разделения разных экземпляров ByteBuffer для того, чтобы обрабатывать каждый экземпляр отдельно. Например, если мы захотим, чтобы заголовок находился в одном ByteBuffer, а тело с данными в другом. На рисунке показано как осуществляется рассеивающееся чтение. Мы передаем массив экземпляров ByteBuffer в ScatteringByteChannel и данные “рассеиваются” с одного канала (channel) к разным буферам.\nСбор (Gathering) работает похожим образом, но данные наоборот - записываются в канал (channel). Вы передаете массив экземпляров ByteBuffer в метод GatheringByteChannel.write() и данные собираются из буферов в канал (channel).\nК сожалению, эта функциональность была сломана до одной из последних обновлений Java 6 и Java 7, использование ее приводило к утечке памяти и OutOfMemoryError. Нужно быть осторожным, когда используешь рассеивание/сбор (scattering/gathering) , и удостовериться что используется необходимая версия Java.\nПодавление известного бага с событием epoll (Squashing the famous epoll bug) На Linux-подобных операционных системах селектор (selector) использует уведомления epoll об IO событиях над объектом. Этот высоко-производительный способ позволят ОС работать асинхронно с сетевым стэком. К сожалению, известный баг с epoll может привести к неправильному состоянию селектора, что приводит к 100% загрузке CPU и бесконечному ожиданию (spinning). Единственный способ восстановить состояние - это пересоздать (recycle) старый селектор и переместить зарегистрированный экземпляр канала в только что созданный селектор. Что же произойдет если метод Selector.select() перестанет блокировать и сразу же вернет результат, даже если ни одного SelectionKeys не будет существовать. Это противоречит тому, что написано в javadoc - Selector.select() must not unblock if nothing is selected. Список проблем с epoll ограничен, и Netty пытается автоматически обнаруживать их и предотвращать. Следующий код демонстрирует баг с epoll:\n{% highlight java %} … while (true) { int selected = selector.select(); \u003c1\u003e Set readyKeys = selector.selectedKeys(); Iterator iterator = readyKeys.iterator(); \u003c2\u003e while (iterator.hasNext()) { \u003c3\u003e … … \u003c4\u003e } } … {% endhighlight %}\nНе блокирует и возвращает 0, если ничего не было выбрано Получает все SelectedKeys, Iterator будет пуст и ничего выбрано не будет Проходит во всем SelectedKeys из Iterator, но в этот блок кода никогда не зайдет, потому что ничего небудет выбрано Дальнейшая работа В итоге получается что небольшой кусок кода съедает весь CPU.\n{% highlight java %} … while (true) { … } … {% endhighlight %}\nЗначение никогда не будет false, и код зависнет в бесконечном цикле и постепенно выест весь CPU, тем самым вытесняя остальные процессы. Это лишь несколько возможных проблеем, с которому можно столкнуться при использовании неблокирующего ввода-вывода. К сожалению, даже после многих лет разработки в этой области некоторые проблемы еще не решены, и Netty успешно абстрагирует разработчиков от этих проблем.\n","wordCount":"2762","inLanguage":"en","image":"https://volyx.in/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2015-01-22T00:00:00Z","dateModified":"2015-01-22T00:00:00Z","author":{"@type":"Person","name":"volyx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://volyx.in/posts/2015-01-22-netty_in_action-new-imported/"},"publisher":{"@type":"Organization","name":"volyx","logo":{"@type":"ImageObject","url":"https://volyx.in/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://volyx.in/ accesskey=h title="volyx (Alt + H)"><img src=https://volyx.in/icon.png alt aria-label=logo height=35>volyx</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://volyx.in/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://volyx.in/categories/ title=categories><span>categories</span></a></li><li><a href=https://volyx.in/about/ title=about><span>about</span></a></li><li><a href=https://volyx.in/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Обзор книги Netty in Action</h1><div class=post-meta><span title='2015-01-22 00:00:00 +0000 UTC'>January 22, 2015</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;volyx</div></header><div class=post-content><p><img loading=lazy src=/images/netty.jpg></p><p>Как сказал David Wheeler, все проблемы в Computer Science могут быть решены еще одним уровнем абстракции. Netty как раз предлагает такой уровень абстракции для клиент-серверных приложений, работающих через NIO(non-blocking input-output). Netty упрощает разработку TCP, UDP серверов, но также дает доступ к использованию низкоуровнего API, представляя свои высокоуровневые абстракции.</p><h2 id=блокирующий-против-неблокирующего-ввода-вывода-в-jvm>Блокирующий против неблокирующего ввода-вывода в JVM<a hidden class=anchor aria-hidden=true href=#блокирующий-против-неблокирующего-ввода-вывода-в-jvm>#</a></h2><p>Продолжающийся рост веба увеличивает потребность в обработке все большего количества данных через сеть и возможностей масштабирования. Эффективность приложений выходит на первое место и встречается со спросом на эту эффективность. К счастью, Java уже поставляется со всеми инструментами, необходимыми для создания эффективных и масштабируемых приложений. Хотя ранние версии Java поддерживали работу с сетью, в Java 1.4 был представлен NIO API, который упрощал разработку клиент-серверных приложений.</p><p>Новый ввод-вывод (NIO.2), представленный в Java 7, дает возможность писать асинхронный, работающий с сетью код и также предлагает более высокоуровневый API , чем его предшественник.</p><p>Для работы с сетью у вас есть всего два варианта:</p><ul><li>Использовать IO, известный как блокирующий ввод-вывод</li><li>Использовать NIO, известный как новый/неблокирующий ввод-вывод</li></ul><p><img alt="Блокирующие сокеты" loading=lazy src=/images/blocking.png><em>Блокирующие сокеты</em></p><p><img alt="Неблокирующие сокеты" loading=lazy src=/images/nonblocking.png><em>Неблокирующие сокеты</em></p><p>На рисунках 1,2 показано, что блокирующий ввод-вывод использует по выделенному потоку на на каждое соединение, это означает, что мы имеем связь один-к-одному между подключениями и потоками, которая ограничивает количество потоков, которое может создать JVM.</p><p>Запомнив это концептуальное отличие, попробуем написать простой сервер, используя разные подходы.
Сервер будет принимать запросы от клиента, и отправлять их назад.</p><p>{% highlight java %}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;</p><p>public class PlainEchoServer {
public void serve(int port) throws IOException {
final ServerSocket socket = new ServerSocket(port); // &lt;1>
try {
while (true) {
final Socket clientSocket = socket.accept(); // &lt;2>
System.out.println(&ldquo;Accepted connection from " +
clientSocket);
new Thread(new Runnable() { // &lt;3>
@Override
public void run() {
try {
BufferedReader reader = new BufferedReader(
new
InputStreamReader(clientSocket.getInputStream()));
PrintWriter writer = new PrintWriter(clientSocket
.getOutputStream(), true);
while(true) { // &lt;4>
writer.println(reader.readLine());
writer.flush();</p><pre><code>                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                        try {
                            clientSocket.close();
                        } catch (IOException ex) {
                            // ignore on close
                        }
                    }
                }
            }).start(); // &lt;5&gt;
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}

public static void main(String[] args) throws IOException {
    new PlainEchoServer().serve(9000);
}
</code></pre><p>}
{% endhighlight %}</p><ol><li>Привязываем сервер к порту</li><li>Блокируем основной поток, пока клиент не подключится</li><li>Создаем новый поток и обрабатываем подключение клиента</li><li>Читаем введенные клиентом данные и записываем их назад</li><li>Запускаем поток</li></ol><p>Подключиться к такому серверу можно с помощью <a href=https://ru.wikipedia.org/wiki/Telnet>telnet</a>, например вот так:</p><p>{% highlight bash %}
telnet localhost 9000
{% endhighlight %}</p><p>На каждого нового клиента требуется создать отдельный поток. Можно, конечно, сделать какой-нибудь pool потоков, чтобы уменьшить затраты на создание каждый раз нового потока, и переиспользовать уже созданные, но это поможет лишь только на время. Основная проблема все же остается: количество одновременных клиентов будет ограничено количеством потоков, обрабатывающих их. Когда приложению необходимо обрабатывать одновременно тысячи клиентов, это становится большой проблемой.</p><p>Эта проблема исчезает, если мы будем использовать NIO, как например, в следующем примере. Но для начала важно узнать основные концепции в NIO.</p><h3 id=основные-концепции-nio>Основные концепции NIO<a hidden class=anchor aria-hidden=true href=#основные-концепции-nio>#</a></h3><p>Java 7 представила новый NIO API, известный как NIO.2, но можно так же использовать и &ldquo;просто&rdquo; NIO. Хотя новый API также асинхронный, он отличается от исходной реализации NIO, как API, так и реализацией. Хотя API не сильно отличаются, они оба имеют одинаковые возможности. Например, обе реализации используют одну и ту же абстракцию под названием <a href=http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html>ByteBuffer</a>, как обертку для данных.</p><h3 id=bytebuffer>Bytebuffer<a hidden class=anchor aria-hidden=true href=#bytebuffer>#</a></h3><p>ByteBuffer - это основа для обоих NIO APIs, так же как и в Netty. ByteBuffer может быть создан как и в Java куче <em>(heap)</em>, так и напрямую, что означает, что он будет хранится вне кучи. Использование буфера напрямую обычно быстрее, когда мы передаем его какому-то каналу <em>(channel)</em>, но стоимость создание и очистки/удаления такого буфера выше. В обоих случаях, API Bytebuffer&rsquo;а один и тот же, который позволяет одним унифицированный образом управлять данными в буфере. ByteBuffer позволяет одним и тем же данным быть легко доступными между разными экземплярами Bytebuffer, без необходимости копировать внутренние данные. Так же он предоставляет другие операции, который ограничивают видимость внутренних данных.</p><p>Slicing ByteBuffer</p><p>Разрезание <em>(Slicing)</em> ByteBuffer позволяет создать новый экземпляр, который будет ссылаться на те же данные, как и исходный ByteBuffer, но делать доступным только часть этих данных. Это полезно для минимизации количества копирований данных, но разрешает доступ только к части этих данных.</p><p>Типичное использование ByteBuffer включает следущее:</p><ul><li>Записать данные в ByteBuffer</li><li>Вызвать <a href=http://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html#flip()>ByteBuffer.flip()</a> для смены режима на чтение</li><li>Чтение данных из ByteBuffer</li><li>Вызов либо <a href=http://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html#clear()>ByteBuffer.clear()</a>, либо <a href=http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html#compact()>ByteBuffer.compact()</a></li></ul><p>Когда данные пишутся в ByteBuffer, он следит за количеством данных, записанных в него, сохраняя позицию индекса записи. Перед тем, как прочитать данные нужно вызвать Bytebuffer.flip(), чтобы сменить режим с записи на режим чтения. Вызов метода ByteBuffer.flip() устанавливает ограничение в ByteBuffer в текущую позицию, а затем устанавливает ее в 0. Таким образом можно считать все данные из ByteBuffer.</p><p>Чтобы опять записать данные в ByteBuffer, нужно вернуться в режим чтения, а затем вызвать следующие методы:</p><ul><li><a href=http://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html#clear()>ByteBuffer.clear()</a> Очищает все данные в буфере</li><li><a href=http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html#compact()>ByteBuffer.compact()</a> Очищает только те данные, которые были прочтены, и перемещает все непрочитанные данные в начало и сдвигает позицию, типичное использование:</li></ul><p>{% highlight java %}
Channel inChannel = &mldr;.;
ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = -1;
do {
bytesRead = inChannel.read(buf); //&lt;1>
if (bytesRead != -1) {
buf.flip(); //&lt;2>
while(buf.hasRemaining()){
System.out.print((char) buf.get()); //&lt;3>
}
buf.clear(); //&lt;4>
}
} while (bytesRead != -1);
inChannel.close();
{% endhighlight %}</p><ol><li>Прочитать данные из канала <em>(Channel)</em> в ByteBuffer</li><li>Подготовим буфер для чтения</li><li>Прочитаем байты из ByteBuffer,с каждым вызовом get() обновляем индекс позиции на 1</li><li>Подготовим буфер для записи</li></ol><p>Теперь, когда понятно, как работать с ByteBuffer, рассмотрим концепцию селекторов <em>(Selectors)</em>.</p><h3 id=работа-с-nio-селекторами-_selectors_>Работа с NIO селекторами <em>(Selectors)</em><a hidden class=anchor aria-hidden=true href=#работа-с-nio-селекторами-_selectors_>#</a></h3><p>NIO API использует основанный на селекторах подход для обработки сетевых событий и данных. Канал <em>(channel)</em> выступает в роли соединения между сущностями, способными осуществлять операции ввода-вывода над такими сущностями как как файл или сокет. Селектор это NIO компонент, который определяет готов ли канал или несколько каналов для чтения/записи, получается что один селектор способен обработать множество подключений, сводящий на нет необходимость для использования модели поток-на-соединение, как было блокирующем сервере из первого примера.</p><p>Чтобы использовать селектор нужно выполнит следующие шаги:</p><ul><li>Создать один или несколько селекторов, в которых можно зарегистрировать каналы <em>(channels)</em></li><li>Когда каналы зарегистрированы, нужно указать события,к которые будут прослушиваться. Существует 4 типа событий:<ul><li>OP_ACCEPT</li><li>OP_CONNECT</li><li>OP_READ</li><li>OP_WRITE</li></ul></li><li>Когда каналы зарегистрированы, необходимо вызвать метод Selector.select(), который заблокирует основной поток, пока какое-нибудь из событий не произойдет.</li><li>Когда метод разблокируется, можно получить все экземпляры SelectionKey(содержит ссылки на зарегистрированный канал и тип события) и выполнить свой код. Что конкретно выполнять зависит от типа события, которое пришло. SelectedKey может содержать больше чем одно событие в один промежуток времени.</li></ul><p>Чтобы увидеть как это работает на деле, нужно реализовать неблокирующую версию сервера из предыдущего примера.</p><p>{% highlight java %}
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;</p><p>public class PlainNioEchoServer {
public void serve(int port) throws IOException {
System.out.println(&ldquo;Listening for connections on port " + port);
ServerSocketChannel serverChannel = ServerSocketChannel.open();
ServerSocket ss = serverChannel.socket();
InetSocketAddress address = new InetSocketAddress(port);
ss.bind(address); // &lt;1>
serverChannel.configureBlocking(false);
Selector selector = Selector.open();
serverChannel.register(selector, SelectionKey.OP_ACCEPT); // &lt;2>
while (true) {
try {
selector.select(); // &lt;3>
} catch (IOException ex) {
ex.printStackTrace();
// handle in a proper way
break;
}
Set readyKeys = selector.selectedKeys();// &lt;4>
Iterator iterator = readyKeys.iterator();
while (iterator.hasNext()) {
SelectionKey key = (SelectionKey) iterator.next();
iterator.remove();//; &lt;5>
try {
if (key.isAcceptable()) {
ServerSocketChannel server = (ServerSocketChannel)
key.channel();
SocketChannel client = server.accept();// &lt;6>
System.out.println(&ldquo;Accepted connection from " +
client);
client.configureBlocking(false);
client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, ByteBuffer.allocate(100));// &lt;7>
}
if (key.isReadable()) {// &lt;8>
SocketChannel client = (SocketChannel) key.channel();
ByteBuffer output = (ByteBuffer) key.attachment();
client.read(output);// &lt;9>
}
if (key.isWritable()) {// &lt;10>
SocketChannel client = (SocketChannel) key.channel();
ByteBuffer output = (ByteBuffer) key.attachment();
output.flip();
client.write(output);// &lt;11>
output.compact();
}
} catch (IOException ex) {
key.cancel();
try {
key.channel().close();
} catch (IOException cex) {
}
}
}
}
}</p><pre><code>public static void main(String[] args) throws IOException {
    new PlainNioEchoServer().serve(9091);
}
</code></pre><p>}
{% endhighlight %}</p><ol><li>Привязываем сервер к порту</li><li>Регистрируем канал с селектором для прослушивания событий типа &ldquo;accept&rdquo;</li><li>Блокируем пока какой-то селектор не сработает</li><li>Получаем все экземпляры SelectedKey</li><li>Убираем SelectedKey из итератора</li><li>Принимаем соединение клиента</li><li>Регистрируем соединение в селекторе и устанавливаем ByteBuffer</li><li>Проверяем SelectedKey на чтение</li><li>Читаем данные в ByteBuffer</li><li>Проверяем SelectedKey на запись</li><li>Записываем данные их ByteBuffer в канал</li></ol><p>Этот пример гораздо сложнее, чем предыдущая версия. Такая сложность - это своего рода компромисс. Асинхронный код обычно сложнее, чем его синхронная версия. Семантически, исходный NIO и NIO.2 API одинаковые, но на самом деле их реализация разная. Далее мы разработаем 3 версию нашего сервера.</p><h3 id=echoserver-основанный-на-nio2>EchoServer, основанный на NIO.2<a hidden class=anchor aria-hidden=true href=#echoserver-основанный-на-nio2>#</a></h3><p>В отличие от первой реализации NIO, NIO.2 позволяет отлавливать конкретные операции ввода-вывода и завершить их специальным классом-обработчиком <em>(CompletionHandler)</em>. Это класс должен выполняется после завершения какой-либо операции. Таким образом он запускается внутренним механизмом NIO и реализация скрыта от разработчика. Так же гарантируется,что только один обработчик будет выполняться для одного канала в один промежуток времени. Этот подход позволяет упростить код, потому что убирается вся сложность работы с многопоточным кодом.</p><p>Основное различие между NIO и NIO.2 это то, что не требуется самому проверять - произошло ли какое-то событие и вызывать необходимый обработчик. В NIO.2 нужно только запустить IO <em>(input-output)</em> операцию и зарегистрировать обработчик <em>(CompletionHandler)</em>, который будет получать уведомления, когда операция завершится. Поэтому необходимость писать свою собственную логику на проверку завершения операция отпадает. Сейчас, давайте посмотрим как будет выглядеть асинхронный <em>EchoServer</em> , реализованный с помощью NIO.2 API.</p><p>{% highlight java %}
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.util.concurrent.CountDownLatch;</p><p>public class PlainNio2EchoServer {</p><pre><code>public void serve(int port) throws IOException {
    System.out.println(&quot;Listening for connections on port &quot; + port);
    final AsynchronousServerSocketChannel serverChannel =
            AsynchronousServerSocketChannel.open();
    InetSocketAddress address = new InetSocketAddress(port);
    serverChannel.bind(address); // &lt;1&gt;
    final CountDownLatch latch = new CountDownLatch(1);
    serverChannel.accept(null, new
            CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() {
                // &lt;2&gt;

                @Override
                public void completed(final AsynchronousSocketChannel channel,
                                      Object attachment) {
                    serverChannel.accept(null, this);// &lt;3&gt;
                    ByteBuffer buffer = ByteBuffer.allocate(100);
                    channel.read(buffer, buffer,
                            new EchoCompletionHandler(channel));// &lt;4&gt;
                }

                @Override
                public void failed(Throwable throwable, Object attachment) {
                    try {
                        serverChannel.close();// &lt;5&gt;
                    } catch (IOException e) {
                        // ingnore on close
                    } finally {
                        latch.countDown();
                    }
                }
            });
    try {
        latch.await();
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}

private final class EchoCompletionHandler implements
        CompletionHandler&lt;Integer, ByteBuffer&gt; {
    private final AsynchronousSocketChannel channel;

    EchoCompletionHandler(AsynchronousSocketChannel channel) {
        this.channel = channel;
    }

    @Override
    public void completed(Integer result, ByteBuffer buffer) {
        buffer.flip();
        channel.write(buffer, buffer, new CompletionHandler&lt;Integer,
                ByteBuffer&gt;() {
            // &lt;6&gt;

            @Override
            public void completed(Integer result, ByteBuffer buffer) {
                if (buffer.hasRemaining()) {
                    channel.write(buffer, buffer, this);// &lt;7&gt;
                } else {
                    buffer.compact();
                    channel.read(buffer, buffer,
                            EchoCompletionHandler.this);// &lt;8&gt;
                }
            }

            @Override
            public void failed(Throwable exc, ByteBuffer attachment) {
                try {
                    channel.close();
                } catch (IOException e) {
                    // ingnore on close
                }
            }
        });
    }

    @Override
    public void failed(Throwable exc, ByteBuffer attachment) {
        try {
            channel.close();
        } catch (IOException e) {
            // ingnore on close
        }
    }
}

public static void main(String[] args) throws IOException {
    new PlainNio2EchoServer().serve(9092);
}
</code></pre><p>}
{% endhighlight %}</p><ol><li>Привяжем сервер к порту</li><li>Начинаем принимать новые подключения. Как только соединение установлено - ompletionHandler будет вызван</li><li>Опять принимаем новый соединения</li><li>Запускаем операцию чтения из channel, CompletionHandler будет уведомлен, когда что-нибудь будет прочитано</li><li>Закрываем socket если произошла ошибка</li><li>Запускаем операцию записи в channel, CompletionHandler будет уведомлен, когда что-нибудь будет записано</li><li>Запускаем еще раз операцию чтения, если что-то осталось в ByteBuffer</li><li>Запускаем операцию чтения в channel, CompletionHandler будет уведомлен, когда что-нибудь будет прочитано</li></ol><p>На первый взгляд может показаться, что в NIO.2 гораздо больше кода, чем в предыдущем примере с NIO. Но можно обратить внимание, что NIO.2 берет обработку многопоточности на себя и также создание так называемого цикла событий <em>(event loop)</em> . Этот подход упрощает разработку многопоточного приложения на NIO, даже если на первый взгляд код кажется сложным. Так как сложность приложений увеличивается, пропасть между этими подходами становится более очевидной, потому что во второй версии получается более читаемый код. Далее мы посмотрим на проблемы, который существуют в обоих реализациях NIO.</p><h2 id=проблемы-с-nio-и-как-netty-решает-эти-проблемы>Проблемы с NIO и как Netty решает эти проблемы<a hidden class=anchor aria-hidden=true href=#проблемы-с-nio-и-как-netty-решает-эти-проблемы>#</a></h2><p>Далее будут рассмотрены некоторые проблемы и ограничения реализации в Java NIO API, и как Netty решает эти проблемы. Если вы уже используете классы из пакета NIO - это шаг в правильном направлении, но пользователи весьма ограничены в способах его использования. Проблемы, с которыми вы столкнетесь, являются результатом дизайна, который был сделан в прошлом, и который сейчас не так то легко поменять.</p><h3 id=проблемы-кроссплатформенности-и-совместимости>Проблемы кроссплатформенности и совместимости<a hidden class=anchor aria-hidden=true href=#проблемы-кроссплатформенности-и-совместимости>#</a></h3><p>NIO фреймворк довольно низкоуровневый и сильно зависит от того, как сама операционная система обрабатывает операции ввода-вывода. Поэтому выполнить требование унифицированного API в Java, который должен вести себя одинаково на всех платформах, не очень простая задача.</p><p>Когда используешь NIO часто можно заметить, что код хорошо работает под Linux, например, в отличие от Windows. Это утверждение справедливо, кстати, не только для NIO.</p><p>[TIP]
Даже если вы не используете NIO, очень важно тестировать ваше приложение на всех операционных системах, которые хотите поддерживать. Если все ваши тесты успешно выполняются на рабочей станции с Linux, удостоверьтесь, что они так же себя ведут и на других ОС. Если не проверили - приготовьтесь к неожиданностям.</p><p>Может показаться, что NIO.2 поддерживается только в Java 7, и если ваше приложение работает на Java 6, то вы не сможете его использовать. Так же пока еще нет поддержки в NIO.2 каналов, работающих с датаграмами <em>(datagram channels)</em> (для приложений использующих UDP), поэтому использование NIO.2 ограничивается только TCP протоколом. Netty успешно скрывает эту проблему, и предоставляет общий API, который работает одинаково и на Java 6 и на Java 7. Не придется беспокоиться о версии Java, Netty API будет работать одинаково хорошо и предоставлять простой и удобный интерфейс.</p><h3 id=использовать-bytebuffer--или-нет>Использовать ByteBuffer &mldr; или нет<a hidden class=anchor aria-hidden=true href=#использовать-bytebuffer--или-нет>#</a></h3><p>Как вы видели ранее, ByteBuffer используется, как контейнер данных. К сожалению, JDK не имеет реализации контейнера ByteBuffer, которая бы позволяла обернуть массив экземпляров ByteBuffer. Эта функциональность бы очень пригодилась для минимизации количества копирований данных. Если вы вдруг решили реализовать эту структуру самостоятельно, не теряйте зря время, ByteBuffer имеет приватный конструктор, и поэтому невозможно от него наследоваться.
Netty предоставляет свою реализацию ByteBuffer, которая обходит эти ограничения и предоставляет несколько вариантов конструкторов, методов для ByteBuffer в своем простом API.</p><h3 id=рассеивание-данных-и-сбор-_scattering-and-gathering-may-leak_>Рассеивание данных и сбор <em>(Scattering and gathering may leak)</em><a hidden class=anchor aria-hidden=true href=#рассеивание-данных-и-сбор-_scattering-and-gathering-may-leak_>#</a></h3><p>Многие реализации каналов <em>(channel)</em> поддерживают рассеивание данных и сбор <em>(scattering and gathering)</em>. Этото функционал позволяет читать и писать из нескольких экземпляров ByteBuffer одновременно, при этом с большей производительностью. Таким способом устроено ядро операционной системы, которое дает большую производительность на чтение/запись, потому что ядро ОС гораздо ближе к &ldquo;железу&rdquo;, и знает как обрабатывать данные наиболее эффективным способом.
Рассеивание/сбор часто используется для разделения разных экземпляров ByteBuffer для того, чтобы обрабатывать каждый экземпляр отдельно. Например, если мы захотим, чтобы заголовок находился в одном ByteBuffer, а тело с данными в другом.
На рисунке показано как осуществляется рассеивающееся чтение. Мы передаем массив экземпляров ByteBuffer в ScatteringByteChannel и данные &ldquo;рассеиваются&rdquo; с одного канала <em>(channel)</em> к разным буферам.</p><p><img alt="Рисунок 3 Рассеивание" loading=lazy src=/images/gathering.png></p><p>Сбор <em>(Gathering)</em> работает похожим образом, но данные наоборот - записываются в канал <em>(channel)</em>. Вы передаете массив экземпляров ByteBuffer в метод GatheringByteChannel.write() и данные собираются из буферов в канал <em>(channel)</em>.</p><p><img alt="Рисунок 4 Сбор" loading=lazy src=/images/gathering1.png></p><p>К сожалению, эта функциональность была сломана до одной из последних обновлений Java 6 и Java 7, использование ее приводило к утечке памяти и OutOfMemoryError. Нужно быть осторожным, когда используешь рассеивание/сбор <em>(scattering/gathering)</em> , и удостовериться что используется необходимая версия Java.</p><h3 id=подавление-известного-бага-с-событием-epoll-_squashing-the-famous-epoll-bug_>Подавление известного бага с событием epoll <em>(Squashing the famous epoll bug)</em><a hidden class=anchor aria-hidden=true href=#подавление-известного-бага-с-событием-epoll-_squashing-the-famous-epoll-bug_>#</a></h3><p>На Linux-подобных операционных системах селектор <em>(selector)</em> использует уведомления <a href=https://ru.wikipedia.org/wiki/Epoll>epoll</a> об IO событиях над объектом. Этот высоко-производительный способ позволят ОС работать асинхронно с сетевым стэком. К сожалению, известный баг с epoll может привести к неправильному состоянию селектора, что приводит к 100% загрузке CPU и бесконечному ожиданию <em>(spinning)</em>. Единственный способ восстановить состояние - это пересоздать <em>(recycle)</em> старый селектор и переместить зарегистрированный экземпляр канала в только что созданный селектор.
Что же произойдет если метод Selector.select() перестанет блокировать и сразу же вернет результат, даже если ни одного SelectionKeys не будет существовать. Это противоречит тому, что написано в javadoc - <a href=http://docs.oracle.com/javase/7/docs/api/java/nio/channels/Selector.html#select()>Selector.select() must not unblock if nothing is selected</a>.
Список проблем с epoll ограничен, и Netty пытается автоматически обнаруживать их и предотвращать. Следующий код демонстрирует баг с epoll:</p><p>{% highlight java %}
&mldr;
while (true) {
int selected = selector.select(); &lt;1>
Set readyKeys = selector.selectedKeys();
Iterator iterator = readyKeys.iterator(); &lt;2>
while (iterator.hasNext()) { &lt;3>
&mldr;
&mldr; &lt;4>
}
}
&mldr;
{% endhighlight %}</p><ol><li>Не блокирует и возвращает 0, если ничего не было выбрано</li><li>Получает все SelectedKeys, Iterator будет пуст и ничего выбрано не будет</li><li>Проходит во всем SelectedKeys из Iterator, но в этот блок кода никогда не зайдет, потому что ничего небудет выбрано</li><li>Дальнейшая работа</li></ol><p>В итоге получается что небольшой кусок кода съедает весь CPU.</p><p>{% highlight java %}
&mldr;
while (true) {
&mldr;
}
&mldr;
{% endhighlight %}</p><p>Значение никогда не будет false, и код зависнет в бесконечном цикле и постепенно выест весь CPU, тем самым вытесняя остальные процессы.
Это лишь несколько возможных проблеем, с которому можно столкнуться при использовании неблокирующего ввода-вывода. К сожалению, даже после многих лет разработки в этой области некоторые проблемы еще не решены, и Netty успешно
абстрагирует разработчиков от этих проблем.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://volyx.in/tags/old-posts/>Old-Posts</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Обзор книги Netty in Action on x" href="https://x.com/intent/tweet/?text=%d0%9e%d0%b1%d0%b7%d0%be%d1%80%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b8%20Netty%20in%20Action&amp;url=https%3a%2f%2fvolyx.in%2fposts%2f2015-01-22-netty_in_action-new-imported%2f&amp;hashtags=old-posts"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Обзор книги Netty in Action on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvolyx.in%2fposts%2f2015-01-22-netty_in_action-new-imported%2f&amp;title=%d0%9e%d0%b1%d0%b7%d0%be%d1%80%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b8%20Netty%20in%20Action&amp;summary=%d0%9e%d0%b1%d0%b7%d0%be%d1%80%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b8%20Netty%20in%20Action&amp;source=https%3a%2f%2fvolyx.in%2fposts%2f2015-01-22-netty_in_action-new-imported%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Обзор книги Netty in Action on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvolyx.in%2fposts%2f2015-01-22-netty_in_action-new-imported%2f&title=%d0%9e%d0%b1%d0%b7%d0%be%d1%80%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b8%20Netty%20in%20Action"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Обзор книги Netty in Action on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvolyx.in%2fposts%2f2015-01-22-netty_in_action-new-imported%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Обзор книги Netty in Action on whatsapp" href="https://api.whatsapp.com/send?text=%d0%9e%d0%b1%d0%b7%d0%be%d1%80%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b8%20Netty%20in%20Action%20-%20https%3a%2f%2fvolyx.in%2fposts%2f2015-01-22-netty_in_action-new-imported%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Обзор книги Netty in Action on telegram" href="https://telegram.me/share/url?text=%d0%9e%d0%b1%d0%b7%d0%be%d1%80%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b8%20Netty%20in%20Action&amp;url=https%3a%2f%2fvolyx.in%2fposts%2f2015-01-22-netty_in_action-new-imported%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Обзор книги Netty in Action on ycombinator" href="https://news.ycombinator.com/submitlink?t=%d0%9e%d0%b1%d0%b7%d0%be%d1%80%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b8%20Netty%20in%20Action&u=https%3a%2f%2fvolyx.in%2fposts%2f2015-01-22-netty_in_action-new-imported%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://volyx.in/>volyx</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>